/[0-9]+/ {
	var err error
    var i int
	i, err = strconv.Atoi(yylex.Text())
	if err != nil {
		yylex.Error(err.Error())
	}
    lval.elem = Integer(i)
	return tIntAtom
}

/"[^"\n]*"/ {
	text := yylex.Text()
    lval.elem = String(text[1:len(text)-1])
    return tStringAtom
}

/[0-9a-zA-Z_+=&*\/<>-]+/ {
	lval.elem = Symbol(yylex.Text())
	return tSymbol
}

/[()'`,@]/ {
    return int(yylex.Text()[0])
}

/[ \t\n]+/   { /* eat up whitespace */ }
/;;[^\n]*/   { /* eat up comments */ }
/./          { yylex.Error(fmt.Sprintf("unrecognized character: %v", yylex.Text())) }
//
package uclisp

import (
    "bytes"
    "fmt"
    "strconv"
)

type result struct {
	Ast Elem
}

func (l *Lexer) Ast(prog Elem) {
	l.parseResult.(*result).Ast = prog
}

func (l *Lexer) Error(err string) {}

func Parse(filename, source string) Elem {
	result := &result{}
	lexer := NewLexerWithInit(bytes.NewBufferString(source), func(lex *Lexer) {
		lex.parseResult = result
	})

	yyErrorVerbose = true
	_ = yyParse(lexer)
	return result.Ast
}